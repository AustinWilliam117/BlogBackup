---
title: '实验4 [bx]和loop的使用'
date: 2021-05-11 23:13:20
tags: ["汇编"]
categories: ["计算机基础"]
---

实验4 [bx] 和 loop 的使用

#### 1. 编程，向内存 0:200 ~ 0:23F 依次传送数据 0~63(3FH)

#### 2. 编程，向内存 0:200 ~ 0:23F 依次传送数据 0~63(3FH)，程序中只能使用9条指令，9条指令中包括 “mov ax,4c00h” 和 “int 21h”

<!--more-->

1和2题一起写

```asm
assume cs:code
code segment

	mov ax,0
	mov ds,ax
	mov cx,40h
	mov bx,200h
	s:mov [bx],bx
	inc bx
	loop s
	
	mov ax,4c00h
	int 21h

code ends
end
```

#### 3. 下面的程序的功能是将 “mov ax,4c00h” 之前的指令复制到内存 0:200 处，补全程序。上机调试，跟踪运行结果。

```asm
assume cs:code
code segment

	mov ax,________  cs
	mov ds,ax
	mov ax,0020h
	mov es,ax
	mov bx,0
	mov cx,________  17h
	s:mov al,[bx]
    mov es:[bx],al
    inc bx
    loop s
    mov ax,4c00h
    int 21h

code ends
end
```

提示：

- 复制的是什么？从哪里到哪里？
- 复制的是什么？有多少个字节？你如何知道要复制的字节的数量？



cx寄存器在循环语句中，常作为计数器使用，loop循环语句把cx寄存器中的值作为判断是否循环的依据。

CX寄存器在debug调试一个可执行程序时，CX的初始值为该程序的字节尺寸大小。



**3.****下面程序的功能是将mov ax,4c00H****之前的指令复制到内存0:200****处，补全程序，上机调试，跟踪运行结果：**

程序分析：

【1】使用debug调试一个EXE文件时候，使用r命令查看寄存器状态，其中cx寄存器的值（初始值）就是该程序代码的大小（按照字节数）。我们可以通过运行debug程序来调试生成的EXE文件，前提你先将CX寄存器赋个值。

​    侧面验证CX寄存器的另一个作用。

【2】cs段寄存器中存储的是指向程序代码段的段地址。此实验是将程序的代码（按字节）复制，故将cs寄存器中的指向代码的段地址赋值给ax，再通过ax寄存器赋值给ds段寄存器。（为什么不能支持从段寄存器cs直接赋值给段寄存器ds呢？回忆下，在8086CPU中，ds、ss、cs、es四个段寄存器存放的都是段地址，在CPU和我们来看。其他的寄存器一般存放的都是数据。

​    这4个段寄存器支持从其他寄存器中赋值，但不允许立即数直接赋值给段寄存器。）

【3】[bx]作为偏移地址为bx的内存单元，它支持的段地址默认是存储在ds段寄存器中的。    本例中ds：[bx]指向的是存储代码段的内存单元（源内存段）。由于ds被占用了，故被写入的内存单元的段地址就没有存储的段寄存器了，es寄存器上场了，es存储了地址为0020H的段地址（目标内存段），那么同样使用[bx]偏移地址的话，必须明确的指出它的前缀，故es：[bx]就指向了内存是0200H的内存单元地址段。